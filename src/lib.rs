//! A safe and convenient wrapper around wl-library-link-sys.
//!
//! # Automatically generating LibraryLink wrappers around Rust functions.
//!
//! See the [`generate_wrapper!()`][macro@generate_wrapper] macro.
//!
//! ## Show backtrace when a panic occurs
//!
//! `generate_wrapper!()` will automatically catch any Rust panic's which occur in the
//! wrapped code, and show an error in the FE with the panic message and source file/line
//! number. It also can optionally show the backtrace. This is configured by the
//! "LIBRARY_LINK_RUST_BACKTRACE" environment variable. Enable it by evaluating:
//!
//! ```wolfram
//! SetEnvironment["LIBRARY_LINK_RUST_BACKTRACE" -> "True"]
//! ```
//!
//! Now the error shown when a panic occurs will include a backtrace.

#![cfg_attr(feature = "nightly", feature(panic_info_message))]

pub mod catch_panic;

use std::ffi::CString;

use wl_expr::Expr;
use wl_expr_macro::wlexpr;
use wl_lang::forms::ToExpr;
use wl_library_link_sys::{mint, WolframLibraryData, LIBRARY_NO_ERROR};

// Re-export `wl_library_link_sys` and `wl_wstp`.
//
// TODO(!): Only selectively re-export the parts of these API's which are actually
//          needed? These should at least have module documentation saying that they
//          shouldn't be used?

/// Re-export of `wl_library_link_sys`
pub use wl_library_link_sys as sys;
pub use wl_wstp as wstp;

pub use wolfram_library_function_macro::wolfram_library_function;

const BACKTRACE_ENV_VAR: &str = "LIBRARY_LINK_RUST_BACKTRACE";

//======================================
// WolframEngine
//======================================

/// This struct should be considered private.
///
/// It is only public because it appears in the expansion of `generate_wrapper`.
#[allow(non_snake_case)]
pub struct WolframEngine {
    // TODO: Is this function thread safe? Can it be called from a thread other than the
    //       one the LibraryLink wrapper was originally invoked from?
    AbortQ: unsafe extern "C" fn() -> mint,
}

impl From<WolframLibraryData> for WolframEngine {
    fn from(libdata: WolframLibraryData) -> Self {
        // TODO(!): Use the library version to verify this is still correct?
        // NOTE: That these fields are even an Option is likely just bindgen being
        //       conservative with function pointers possibly being null.
        // TODO: Investigate making bindgen treat these as non-null fields?
        WolframEngine {
            // TODO(!): Audit this
            AbortQ: unsafe { *libdata }.AbortQ.expect("AbortQ callback is NULL"),
        }
    }
}

impl WolframEngine {
    /// Returns `true` if the user has requested that the current evaluation be aborted.
    ///
    /// Programs should finish what they are doing and return control of this thread to
    /// to the kernel as quickly as possible. They should not exit the process or
    /// otherwise terminate execution, simply return up the call stack.
    pub fn aborted(&self) -> bool {
        let val: mint = unsafe { (self.AbortQ)() };
        val == 1
    }

    // TODO:
    // /// Convenience wrapper around evaluate `Print`.
    // fn print(&self, args: impl Into<PrintArgs>);

    // TODO:
    // /// Evaluate an expression in the current kernel.
    // ///
    // /// TODO: What does Stack[] give in this situation? What does Stack[] give inside any
    // ///       builtin function?
    // fn evaluate(&self, expr: Expr) -> EvaluationData;
}

// Because the wrapper is generated by macro, it's not necessary for LibraryLink to have a
// stable ABI?

// pub struct EvaluationData {
//     pub value: Expr,
//     /// Message that were generated during the evaluation.
//     pub message: Vec<forms::Message>,
// }

//======================================
// LibraryLinkStatus
//======================================

#[derive(Copy, Clone, Debug)]
pub enum LibraryLinkStatus {
    NoError,
    FunctionError,
    TypeError,
}

impl From<LibraryLinkStatus> for u32 {
    fn from(status: LibraryLinkStatus) -> u32 {
        use self::sys::{LIBRARY_FUNCTION_ERROR, LIBRARY_TYPE_ERROR};

        match status {
            LibraryLinkStatus::NoError => LIBRARY_NO_ERROR,
            LibraryLinkStatus::FunctionError => LIBRARY_FUNCTION_ERROR,
            LibraryLinkStatus::TypeError => LIBRARY_TYPE_ERROR,
        }
    }
}

// impl Try for LibraryLinkStatus {
//     type Ok = ();
//     type Error = Self;

//     fn into_result(self) -> Result<Self::Ok, Self::Error> {
//         match self {
//             LibraryLinkStatus::NoError => Ok(()),
//             s @ LibraryLinkStatus::FunctionError => Err(s),
//             s @ LibraryLinkStatus::TypeError => Err(s),
//         }
//     }

//     fn from_error(err: Self) -> Self {
//         match err {
//             LibraryLinkStatus::NoError => {
//                 panic!("Try::from_error for LibraryLinkStatus: got NoError")
//             },
//             LibraryLinkStatus::FunctionError | LibraryLinkStatus::TypeError => err,
//         }
//     }

//     fn from_ok(_ok: ()) -> Self {
//         LibraryLinkStatus::NoError
//     }
// }

// TODO: Allow any type which implements FromExpr in wrapper parameter lists?

//======================================
// #[wolfram_library_function] helpers
//======================================

/// Private.
///
/// Helper function used to implement the
/// [`wolfram_library_function`][macro@wolfram_library_function] macro.
pub fn call_wolfram_library_function(
    libdata: WolframLibraryData,
    unsafe_link: wstp::sys::WSLINK,
    function: fn(&WolframEngine, Vec<Expr>) -> Expr,
) -> std::os::raw::c_uint {
    use self::{
        catch_panic::{call_and_catch_panic, CaughtPanic},
        wstp::{
            sys::{WSEndPacket, WSPutString},
            WSTPLink,
        },
    };
    use wl_expr::ExprKind;

    let result: Result<(), CaughtPanic> = unsafe {
        call_and_catch_panic(|| {
            // Contruct the engine
            let engine = WolframEngine::from(libdata);

            let link = WSTPLink::new(unsafe_link);

            let arguments: Expr = match link.get_expr() {
                Ok(args) => args,
                Err(message) => {
                    let _: Result<_, _> = link.put_expr(&wlexpr! {
                        Failure["LibraryFunctionWSTPError", <|
                            "Message" -> %[Expr::string(message)]
                        |>]
                    });
                    return;
                },
            };

            let arguments = match arguments.to_kind() {
                ExprKind::Normal(normal) => normal.contents,
                _ => panic!("WSTP argument expression was non-Normal"),
            };

            let result: Expr = function(&engine, arguments);

            link.put_expr(&result).expect(
                "LibraryFunction result expression could not be written to WSTP link",
            );
        })
    };

    match result {
        Ok(()) => LIBRARY_NO_ERROR,
        Err(caught_panic) => unsafe {
            use wl_lang::forms::ToPrettyExpr;
            // FIXME: Fix unwraps + return this as a full expr
            let cstring =
                CString::new(caught_panic.to_pretty_expr().to_string()).unwrap();

            WSPutString(unsafe_link, cstring.as_ptr());

            WSEndPacket(unsafe_link);

            LIBRARY_NO_ERROR
        },
    }
}

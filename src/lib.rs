//! A safe and convenient wrapper around Wolfram [LibraryLink][library-link-guide].
//!
//! LibraryLink is framework for writing C/Rust programs which can be
//! [loaded][library-function-load] by the Wolfram Language.
//!
//! The primary interface provided by this library is [`#[wolfram_library_function]`][wlf]:
//!
//! ```
//! use wl_expr::Expr;
//! use wl_library_link::{wolfram_library_function, WolframEngine};
//!
//! #[wolfram_library_function]
//! pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
//!     for arg in args {
//!         engine.evaluate(&Expr! { Print["Hello ", 'arg, "!"] });
//!     }
//!  
//!     Expr::null()
//! }
//! ```
//!
//! ## Show backtrace when a panic occurs
//!
//! Functions wrapped using [`wolfram_library_function`][wlf] will automatically catch any
//! Rust panic's which occur in the wrapped code, and return a [`Failure`][failure] object
//! with the panic message and source file/line number. It also can optionally show the
//! backtrace. This is configured by the `"LIBRARY_LINK_RUST_BACKTRACE"` environment
//! variable. Enable it by evaluating:
//!
//! ```wolfram
//! SetEnvironment["LIBRARY_LINK_RUST_BACKTRACE" -> "True"]
//! ```
//!
//! Now the error shown when a panic occurs will include a backtrace.
//!
//! Note that the error message may include more information if the `"nightly"`
//! [feature][cargo-features] of `wl-library-link` is enabled.
//!
//! [wlf]: attr.wolfram_library_function.html
//! [library-link-guide]: https://reference.wolfram.com/language/guide/LibraryLink.html
//! [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
//! [failure]: https://reference.wolfram.com/language/ref/Failure.html
//! [cargo-features]: https://doc.rust-lang.org/cargo/reference/features.html

#![cfg_attr(feature = "nightly", feature(panic_info_message))]
#![deny(missing_docs)]

/// This module is *semver exempt*. This is not intended to be part of the public API of
/// wl-library-link.
///
/// Utility for catching panics, capturing a backtrace, and extracting the panic
/// message.
#[doc(hidden)]
pub mod catch_panic;

use std::ffi::CString;

use wl_expr::{forms::ToPrettyExpr, Expr, ExprKind};
use wl_library_link_sys::{mint, WolframLibraryData, LIBRARY_NO_ERROR, MLINK};
use wl_symbol_table as sym;
use wl_wstp::WSTPLink;

// Re-export `wl_library_link_sys` and `wl_wstp`.
//
// TODO(!): Only selectively re-export the parts of these API's which are actually
//          needed? These should at least have module documentation saying that they
//          shouldn't be used?

/// Re-export of `wl_library_link_sys`
pub use wl_library_link_sys as sys;
pub use wl_wstp as wstp;

/// Attribute to generate a [LibraryLink][library-link]-compatible wrapper around a Rust
/// function.
///
/// The wrapper function generated by this macro must be loaded using
/// [`LibraryFunctionLoad`][library-function-load], with [`LinkObject`][link-object] as
/// the argument and return value types.
///
/// A function written like:
///
/// ```
/// use wl_expr::Expr;
/// use wl_library_link::{WolframEngine, wolfram_library_function};
///
/// #[wolfram_library_function]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     for arg in args {
///         engine.evaluate(&Expr! { Print["Hello ", 'arg] });
///     }
///
///     Expr::null()
/// }
/// ```
///
/// can be loaded in the Wolfram Language by evaluating:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib",
///     "say_hello_wrapper",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
/// ## Options
///
/// #### Generated wrapper name
///
/// By default, the generated wrapper function will be the name of the function the
/// attribute it applied to with the fragment `_wrapper` appended. E.g., the function
/// `say_hello` has a wrapper named `say_hello_wrapper`.
///
/// This can be controlled via the `name` option of `wolfram_library_function`, which sets
/// the name of generated Wolfram library function:
///
/// ```
/// # use wl_expr::Expr;
/// # use wl_library_link::{WolframEngine, wolfram_library_function};
/// #
/// #[wolfram_library_function(name = "WL_greet")]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     // ...
/// #   Expr::null()
/// }
/// ```
///
/// The `LibraryFunctionLoad` invocation should change to:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib"
///     "WL_greet",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
///
/// [library-link]: https://reference.wolfram.com/language/guide/LibraryLink.html
/// [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
/// [link-object]: https://reference.wolfram.com/language/ref/LinkObject.html
#[doc(inline)]
pub use wolfram_library_function_macro::wolfram_library_function;

const BACKTRACE_ENV_VAR: &str = "LIBRARY_LINK_RUST_BACKTRACE";

//======================================
// WolframEngine
//======================================

/// Callbacks to the Wolfram Engine.
#[allow(non_snake_case)]
pub struct WolframEngine {
    wl_lib: WolframLibraryData,

    // TODO: Is this function thread safe? Can it be called from a thread other than the
    //       one the LibraryLink wrapper was originally invoked from?
    AbortQ: unsafe extern "C" fn() -> mint,
    getWSLINK: unsafe extern "C" fn(WolframLibraryData) -> MLINK,
    processWSLINK: unsafe extern "C" fn(MLINK) -> i32,
}

impl WolframEngine {
    /// Initialize a `WolframEngine` from the callbacks in a [`WolframLibraryData`]
    /// object.
    unsafe fn from_library_data(libdata: WolframLibraryData) -> Self {
        // TODO(!): Use the library version to verify this is still correct?
        // TODO(!): Audit this
        // NOTE: That these fields are even an Option is likely just bindgen being
        //       conservative with function pointers possibly being null.
        // TODO: Investigate making bindgen treat these as non-null fields?
        let lib = *libdata;
        WolframEngine {
            wl_lib: libdata,

            AbortQ: lib.AbortQ.expect("AbortQ callback is NULL"),
            getWSLINK: lib.getWSLINK.expect("getWSLINK callback is NULL"),
            processWSLINK: lib.processWSLINK.expect("processWSLINK callback is NULL"),
        }
    }

    /// Returns `true` if the user has requested that the current evaluation be aborted.
    ///
    /// Programs should finish what they are doing and return control of this thread to
    /// to the kernel as quickly as possible. They should not exit the process or
    /// otherwise terminate execution, simply return up the call stack.
    ///
    /// Within Rust code reached through a `#[wolfram_library_function]` wrapper,
    /// `panic!()` can be used to quickly unwind the call stack to the appropriate place.
    /// Note that this will not work if the current library is built with
    /// `panic = "abort"`. See the [`panic`][panic-option] profile configuration option
    /// for more information.
    ///
    /// [panic-option]: https://doc.rust-lang.org/cargo/reference/profiles.html#panic
    pub fn aborted(&self) -> bool {
        let val: mint = unsafe { (self.AbortQ)() };
        val == 1
    }

    /// Evaluate `expr` by calling back into the Wolfram Kernel.
    ///
    /// TODO: Specify and document what happens if the evaluation of `expr` triggers a
    ///       kernel abort (such as a `Throw[]` in the code).
    pub fn evaluate(&self, expr: &Expr) -> Expr {
        match self.try_evaluate(expr) {
            Ok(returned) => returned,
            Err(msg) => panic!(
                "WolframEngine::evaluate: evaluation of expression failed: \
                {}\n\texpression: {}",
                msg, expr
            ),
        }
    }

    /// Attempt to evaluate `expr`, returning an error if a WSTP transport error occurred
    /// or evaluation failed.
    pub fn try_evaluate(&self, expr: &Expr) -> Result<Expr, String> {
        let link = self.get_wstp_link();

        // Send an EvaluatePacket['expr].
        let _: () = link.put_expr(&Expr! { EvaluatePacket['expr] })?;

        let _: () = self.process_wstp_link(&link)?;

        let return_packet: Expr = link.get_expr()?;

        let returned_expr = match return_packet.kind() {
            ExprKind::Normal(normal) => {
                debug_assert!(normal.has_head(&*sym::ReturnPacket));
                debug_assert!(normal.contents.len() == 1);
                normal.contents[0].clone()
            },
            _ => return Err(format!(
                "WolframEngine::try_evaluate: returned expression was not ReturnPacket: {}",
                return_packet
            )),
        };

        Ok(returned_expr)
    }

    fn get_wstp_link(&self) -> WSTPLink {
        unsafe {
            let unsafe_link = (self.getWSLINK)(self.wl_lib);
            // Go from *mut MLINK -> *mut WSLINK
            WSTPLink::new(unsafe_link as *mut _)
        }
    }

    fn process_wstp_link(&self, link: &WSTPLink) -> Result<(), String> {
        let raw_link = unsafe { link.raw_link() };

        // Process the packet on the link.
        let code: i32 = unsafe { (self.processWSLINK)(raw_link as *mut _) };

        if code == 0 {
            let error_message = link
                .error_message()
                .unwrap_or_else(|| "unknown error occurred on WSTPLink".into());

            return Err(error_message);
        }

        Ok(())
    }
}

// TODO: Allow any type which implements FromExpr in wrapper parameter lists?

//======================================
// #[wolfram_library_function] helpers
//======================================

/// Private. Helper function used to implement [`#[wolfram_library_function]`][wlf] .
///
/// [wlf]: attr.wolfram_library_function.html
pub fn call_wolfram_library_function(
    libdata: WolframLibraryData,
    unsafe_link: wstp::sys::WSLINK,
    function: fn(&WolframEngine, Vec<Expr>) -> Expr,
) -> std::os::raw::c_uint {
    use self::{
        catch_panic::{call_and_catch_panic, CaughtPanic},
        wstp::sys::{WSEndPacket, WSPutString},
    };

    let result: Result<(), CaughtPanic> = unsafe {
        call_and_catch_panic(|| {
            // Contruct the engine
            let engine = WolframEngine::from_library_data(libdata);

            let link = WSTPLink::new(unsafe_link);

            let arguments: Expr = match link.get_expr() {
                Ok(args) => args,
                Err(message) => {
                    let _: Result<_, _> = link.put_expr(&Expr! {
                        Failure["LibraryFunctionWSTPError", <|
                            "Message" -> %[Expr::string(message)]
                        |>]
                    });
                    return;
                },
            };

            let arguments = match arguments.to_kind() {
                ExprKind::Normal(normal) => normal.contents,
                _ => panic!("WSTP argument expression was non-Normal"),
            };

            let result: Expr = function(&engine, arguments);

            link.put_expr(&result).expect(
                "LibraryFunction result expression could not be written to WSTP link",
            );
        })
    };

    match result {
        Ok(()) => LIBRARY_NO_ERROR,
        Err(caught_panic) => unsafe {
            // FIXME: Fix unwraps + return this as a full expr
            let cstring =
                CString::new(caught_panic.to_pretty_expr().to_string()).unwrap();

            WSPutString(unsafe_link, cstring.as_ptr());

            WSEndPacket(unsafe_link);

            LIBRARY_NO_ERROR
        },
    }
}

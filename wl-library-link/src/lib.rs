//! A safe and convenient wrapper around Wolfram [LibraryLink][library-link-guide].
//!
//! LibraryLink is framework for writing C/Rust programs which can be
//! [loaded][library-function-load] by the Wolfram Language.
//!
//! The primary interface provided by this library is [`#[wolfram_library_function]`][wlf]:
//!
//! ```
//! use wl_expr::Expr;
//! use wl_library_link::{wolfram_library_function, WolframEngine};
//!
//! #[wolfram_library_function]
//! pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
//!     for arg in args {
//!         engine.evaluate(&Expr! { Print["Hello ", 'arg, "!"] });
//!     }
//!  
//!     Expr::null()
//! }
//! ```
//!
//! ## Show backtrace when a panic occurs
//!
//! Functions wrapped using [`wolfram_library_function`][wlf] will automatically catch any
//! Rust panic's which occur in the wrapped code, and return a [`Failure`][failure] object
//! with the panic message and source file/line number. It also can optionally show the
//! backtrace. This is configured by the `"LIBRARY_LINK_RUST_BACKTRACE"` environment
//! variable. Enable it by evaluating:
//!
//! ```wolfram
//! SetEnvironment["LIBRARY_LINK_RUST_BACKTRACE" -> "True"]
//! ```
//!
//! Now the error shown when a panic occurs will include a backtrace.
//!
//! Note that the error message may include more information if the `"nightly"`
//! [feature][cargo-features] of `wl-library-link` is enabled.
//!
//! [wlf]: attr.wolfram_library_function.html
//! [library-link-guide]: https://reference.wolfram.com/language/guide/LibraryLink.html
//! [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
//! [failure]: https://reference.wolfram.com/language/ref/Failure.html
//! [cargo-features]: https://doc.rust-lang.org/cargo/reference/features.html

#![cfg_attr(feature = "nightly", feature(panic_info_message))]
#![deny(missing_docs)]

/// This module is *semver exempt*. This is not intended to be part of the public API of
/// wl-library-link.
///
/// Utility for catching panics, capturing a backtrace, and extracting the panic
/// message.
#[doc(hidden)]
pub mod catch_panic;
mod library_data;
mod numeric_array;


use std::convert::TryFrom;
use std::ffi::CString;

use wl_expr::{forms::ToPrettyExpr, Expr, ExprKind};
use wl_library_link_sys::{mint, LIBRARY_NO_ERROR, WSLINK};
use wl_symbol_table as sym;
use wstp::Link;

pub use self::numeric_array::{NumericArray, NumericArrayKind};
use self::sys::MArgument;


pub use wl_library_link_sys as sys;
pub use wstp;

pub use self::library_data::initialize;

pub(crate) use self::library_data::get_library_data;

/// Attribute to generate a [LibraryLink][library-link]-compatible wrapper around a Rust
/// function.
///
/// The wrapper function generated by this macro must be loaded using
/// [`LibraryFunctionLoad`][library-function-load], with [`LinkObject`][link-object] as
/// the argument and return value types.
///
/// A function written like:
///
/// ```
/// use wl_expr::Expr;
/// use wl_library_link::{WolframEngine, wolfram_library_function};
///
/// #[wolfram_library_function]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     for arg in args {
///         engine.evaluate(&Expr! { Print["Hello ", 'arg] });
///     }
///
///     Expr::null()
/// }
/// ```
///
/// can be loaded in the Wolfram Language by evaluating:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib",
///     "say_hello_wrapper",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
/// ## Options
///
/// #### Generated wrapper name
///
/// By default, the generated wrapper function will be the name of the function the
/// attribute it applied to with the fragment `_wrapper` appended. For example, the
/// function `say_hello` has a wrapper named `say_hello_wrapper`.
///
/// This can be controlled via the `name` option of `wolfram_library_function`, which sets
/// the name of generated Wolfram library function:
///
/// ```
/// # use wl_expr::Expr;
/// # use wl_library_link::{WolframEngine, wolfram_library_function};
/// #
/// #[wolfram_library_function(name = "WL_greet")]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     // ...
/// #   Expr::null()
/// }
/// ```
///
/// The `LibraryFunctionLoad` invocation should change to:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib"
///     "WL_greet",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
///
/// [library-link]: https://reference.wolfram.com/language/guide/LibraryLink.html
/// [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
/// [link-object]: https://reference.wolfram.com/language/ref/LinkObject.html
#[doc(inline)]
pub use wolfram_library_function_macro::wolfram_library_function;

const BACKTRACE_ENV_VAR: &str = "LIBRARY_LINK_RUST_BACKTRACE";

//======================================
// WolframEngine
//======================================

/// Callbacks to the Wolfram Engine.
#[allow(non_snake_case)]
pub struct WolframEngine {
    wl_lib: sys::WolframLibraryData,

    // TODO: Is this function thread safe? Can it be called from a thread other than the
    //       one the LibraryLink wrapper was originally invoked from?
    AbortQ: unsafe extern "C" fn() -> mint,
    getWSLINK: unsafe extern "C" fn(sys::WolframLibraryData) -> WSLINK,
    processWSLINK: unsafe extern "C" fn(WSLINK) -> i32,
}

impl WolframEngine {
    /// Initialize a `WolframEngine` from the callbacks in a [`WolframLibraryData`]
    /// object.
    unsafe fn from_library_data(libdata: sys::WolframLibraryData) -> Self {
        // TODO(!): Use the library version to verify this is still correct?
        // TODO(!): Audit this
        // NOTE: That these fields are even an Option is likely just bindgen being
        //       conservative with function pointers possibly being null.
        // TODO: Investigate making bindgen treat these as non-null fields?
        let lib = *libdata;
        WolframEngine {
            wl_lib: libdata,

            AbortQ: lib.AbortQ.expect("AbortQ callback is NULL"),
            getWSLINK: lib.getWSLINK.expect("getWSLINK callback is NULL"),
            processWSLINK: lib.processWSLINK.expect("processWSLINK callback is NULL"),
        }
    }

    /// Returns `true` if the user has requested that the current evaluation be aborted.
    ///
    /// Programs should finish what they are doing and return control of this thread to
    /// to the kernel as quickly as possible. They should not exit the process or
    /// otherwise terminate execution, simply return up the call stack.
    ///
    /// Within Rust code reached through a `#[wolfram_library_function]` wrapper,
    /// `panic!()` can be used to quickly unwind the call stack to the appropriate place.
    /// Note that this will not work if the current library is built with
    /// `panic = "abort"`. See the [`panic`][panic-option] profile configuration option
    /// for more information.
    ///
    /// [panic-option]: https://doc.rust-lang.org/cargo/reference/profiles.html#panic
    pub fn aborted(&self) -> bool {
        let val: mint = unsafe { (self.AbortQ)() };
        val == 1
    }

    /// Evaluate `expr` by calling back into the Wolfram Kernel.
    ///
    /// TODO: Specify and document what happens if the evaluation of `expr` triggers a
    ///       kernel abort (such as a `Throw[]` in the code).
    pub fn evaluate(&self, expr: &Expr) -> Expr {
        match self.try_evaluate(expr) {
            Ok(returned) => returned,
            Err(msg) => panic!(
                "WolframEngine::evaluate: evaluation of expression failed: \
                {}: \n\texpression: {}",
                msg, expr
            ),
        }
    }

    /// Attempt to evaluate `expr`, returning an error if a WSTP transport error occurred
    /// or evaluation failed.
    pub fn try_evaluate(&self, expr: &Expr) -> Result<Expr, String> {
        let mut link = self.get_wstp_link();

        // Send an EvaluatePacket['expr].
        let _: () = link
            .put_expr(&Expr! { EvaluatePacket['expr] })
            .map_err(|e| e.to_string())?;

        let _: () = self.process_wstp_link(&link)?;

        let return_packet: Expr = link.get_expr().map_err(|e| e.to_string())?;

        let returned_expr = match return_packet.kind() {
            ExprKind::Normal(normal) => {
                debug_assert!(normal.has_head(&*sym::ReturnPacket));
                debug_assert!(normal.contents.len() == 1);
                normal.contents[0].clone()
            },
            _ => return Err(format!(
                "WolframEngine::try_evaluate: returned expression was not ReturnPacket: {}",
                return_packet
            )),
        };

        Ok(returned_expr)
    }

    fn get_wstp_link(&self) -> Link {
        unsafe {
            let unsafe_link = (self.getWSLINK)(self.wl_lib);
            // Go from *mut MLINK -> *mut WSLINK
            Link::unchecked_new(unsafe_link as *mut _)
        }
    }

    fn process_wstp_link(&self, link: &Link) -> Result<(), String> {
        let raw_link = unsafe { link.raw_link() };

        // Process the packet on the link.
        let code: i32 = unsafe { (self.processWSLINK)(raw_link as *mut _) };

        if code == 0 {
            let error_message = link
                .error_message()
                .unwrap_or_else(|| "unknown error occurred on WSTP Link".into());

            return Err(error_message);
        }

        Ok(())
    }

    // FIXME: This is unsafe, because the NumericArray data might not be initialized(?).
    unsafe fn new_numeric_byte_array(&self, length: usize) -> NumericArray<u8> {
        use crate::sys::MNumericArray;

        let mut byte_array: MNumericArray = std::ptr::null_mut();

        let rank = 1;

        let na_funs = *(*self.wl_lib).numericarrayLibraryFunctions;

        let err_code = (na_funs.MNumericArray_new.unwrap())(
            sys::MNumericArray_Data_Type::MNumericArray_Type_UBit8,
            rank,
            &i64::try_from(length).expect("NumericArray length overflows i64"),
            &mut byte_array,
        );

        if err_code != 0 {
            panic!(
                "new_numeric_error(): error creating new NumericArray: {}",
                err_code
            );
        }

        NumericArray::from_raw(byte_array)
    }
}

// TODO: Allow any type which implements FromExpr in wrapper parameter lists?


//======================================
// #[wolfram_library_function] helpers
//======================================

//==================
// WSTP helpers
//==================

/// Private. Helper function used to implement [`#[wolfram_library_function]`][wlf] .
///
/// [wlf]: attr.wolfram_library_function.html
pub fn call_wstp_wolfram_library_function_expr_list(
    libdata: sys::WolframLibraryData,
    unsafe_link: wstp::sys::WSLINK,
    function: fn(&WolframEngine, Vec<Expr>) -> Expr,
) -> std::os::raw::c_uint {
    call_wstp_wolfram_library_function(
        libdata,
        unsafe_link,
        |engine: &WolframEngine, argument_expr: Expr| -> Expr {
            let arguments = match argument_expr.to_kind() {
                ExprKind::Normal(normal) => normal.contents,
                _ => panic!("WSTP argument expression was non-Normal"),
            };

            function(engine, arguments)
        },
    )
}

/// Private. Helper function used to implement [`#[wolfram_library_function]`][wlf] .
///
/// [wlf]: attr.wolfram_library_function.html
pub fn call_wstp_wolfram_library_function<
    F: FnOnce(&WolframEngine, Expr) -> Expr + std::panic::UnwindSafe,
>(
    libdata: sys::WolframLibraryData,
    mut unsafe_link: wstp::sys::WSLINK,
    function: F,
) -> std::os::raw::c_uint {
    use self::{
        catch_panic::{call_and_catch_panic, CaughtPanic},
        wstp::sys::{WSEndPacket, WSPutString},
    };

    let result: Result<(), CaughtPanic> = unsafe {
        call_and_catch_panic(move || {
            // Contruct the engine
            let engine = WolframEngine::from_library_data(libdata);

            let link = Link::unchecked_ref_cast_mut(&mut unsafe_link);

            let arguments: Expr = match link.get_expr() {
                Ok(args) => args,
                Err(message) => {
                    // Skip reading the argument list packet.
                    if link.raw_get_next().and_then(|_| link.new_packet()).is_err() {
                        return;
                    }

                    let _: Result<_, _> = link.put_expr(&Expr! {
                        Failure["LibraryFunctionWSTPError", <|
                            "Message" -> %[Expr::string(message.to_string())]
                        |>]
                    });
                    return;
                },
            };

            let result: Expr = function(&engine, arguments);

            link.put_expr(&result).expect(
                "LibraryFunction result expression could not be written to WSTP link",
            );
        })
    };

    match result {
        Ok(()) => LIBRARY_NO_ERROR,
        Err(caught_panic) => unsafe {
            // FIXME: Fix unwraps + return this as a full expr
            let cstring =
                CString::new(caught_panic.to_pretty_expr().to_string()).unwrap();

            WSPutString(unsafe_link, cstring.as_ptr());

            WSEndPacket(unsafe_link);

            LIBRARY_NO_ERROR
        },
    }
}

//==================
// WXF helpers
//==================

/// Private. Helper function used to implement [`#[wolfram_library_function]`][wlf] .
///
/// [wlf]: attr.wolfram_library_function.html
pub fn call_wxf_wolfram_library_function_expr_list(
    libdata: sys::WolframLibraryData,
    wxf_argument: MArgument,
    wxf_result: MArgument,
    function: fn(&WolframEngine, Vec<Expr>) -> Expr,
) -> std::os::raw::c_uint {
    call_wxf_wolfram_library_function(
        libdata,
        wxf_argument,
        wxf_result,
        |engine: &WolframEngine, argument_expr: Expr| -> Expr {
            let arguments = match argument_expr.to_kind() {
                ExprKind::Normal(normal) => normal.contents,
                _ => panic!("WXF argument expression was non-Normal"),
            };

            function(engine, arguments)
        },
    )
}

/// Private. Helper function used to implement [`#[wolfram_library_function]`][wlf] .
///
/// [wlf]: attr.wolfram_library_function.html
pub fn call_wxf_wolfram_library_function<
    F: FnOnce(&WolframEngine, Expr) -> Expr + std::panic::UnwindSafe,
>(
    libdata: sys::WolframLibraryData,
    wxf_argument: MArgument,
    wxf_result: MArgument,
    function: F,
) -> std::os::raw::c_uint {
    use self::catch_panic::{call_and_catch_panic, CaughtPanic};

    let result: Result<(), CaughtPanic> = unsafe {
        call_and_catch_panic(|| {
            // Contruct the engine
            let engine = WolframEngine::from_library_data(libdata);

            let argument_numeric_array = NumericArray::from_raw(*wxf_argument.numeric)
                .try_into_kind::<u8>()
                .expect(
                    "wolfram_library_function: expected NumericArray of UnsignedInteger8",
                );

            let arguments = wxf::deserialize(argument_numeric_array.as_slice()).expect(
                "wolfram_library_function: failed to deserialize argument WXF data",
            );

            let result: Expr = function(&engine, arguments);

            *wxf_result.numeric =
                wxf_numeric_array_from_expr(&engine, &result).into_raw();
        })
    };

    match result {
        Ok(()) => LIBRARY_NO_ERROR,
        // NOTE: This block tries to minimize calls to functions which could potentially
        //       panic, on a best-effort basis. If a panic were to occur within this code
        //       it would not be caught and the Rust stack unwinder would likely abort
        //       the Kernel process, which isn't very user friendly.
        Err(caught_panic) => {
            let pretty_expr = caught_panic.to_pretty_expr();

            unsafe {
                let engine = WolframEngine::from_library_data(libdata);
                *wxf_result.numeric =
                    wxf_numeric_array_from_expr(&engine, &pretty_expr).into_raw();
            }

            LIBRARY_NO_ERROR
        },
    }
}

unsafe fn wxf_numeric_array_from_expr(
    engine: &WolframEngine,
    expr: &Expr,
) -> NumericArray<u8> {
    let result_wxf: Vec<u8> = wxf::serialize(expr)
        .expect("wolfram_library_function: failed to serialize result expression to WXF");

    let mut numeric_array = engine.new_numeric_byte_array(result_wxf.len());

    debug_assert!(numeric_array.as_slice_mut().len() == result_wxf.len());

    // FIXME: It's very inefficient to do this copy 1 byte at a time. Replace this with
    //        std::ptr::copy_nonoverlapping().
    for (index, byte) in numeric_array.as_slice_mut().iter_mut().enumerate() {
        *byte = result_wxf[index];
    }

    numeric_array
}

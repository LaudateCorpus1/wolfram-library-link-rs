//! A safe and convenient wrapper around Wolfram [LibraryLink][library-link-guide].
//!
//! LibraryLink is framework for writing C/Rust programs which can be
//! [loaded][library-function-load] by the Wolfram Language.
//!
//! The primary interface provided by this library is [`#[wolfram_library_function]`][wlf]:
//!
//! ```
//! use wl_expr::Expr;
//! use wl_library_link::{wolfram_library_function, WolframEngine};
//!
//! #[wolfram_library_function]
//! pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
//!     for arg in args {
//!         engine.evaluate(&Expr! { Print["Hello ", 'arg, "!"] });
//!     }
//!
//!     Expr::null()
//! }
//! ```
//!
//! ## Show backtrace when a panic occurs
//!
//! Functions wrapped using [`wolfram_library_function`][wlf] will automatically catch any
//! Rust panic's which occur in the wrapped code, and return a [`Failure`][failure] object
//! with the panic message and source file/line number. It also can optionally show the
//! backtrace. This is configured by the `"LIBRARY_LINK_RUST_BACKTRACE"` environment
//! variable. Enable it by evaluating:
//!
//! ```wolfram
//! SetEnvironment["LIBRARY_LINK_RUST_BACKTRACE" -> "True"]
//! ```
//!
//! Now the error shown when a panic occurs will include a backtrace.
//!
//! Note that the error message may include more information if the `"nightly"`
//! [feature][cargo-features] of `wl-library-link` is enabled.
//!
//! [wlf]: attr.wolfram_library_function.html
//! [library-link-guide]: https://reference.wolfram.com/language/guide/LibraryLink.html
//! [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
//! [failure]: https://reference.wolfram.com/language/ref/Failure.html
//! [cargo-features]: https://doc.rust-lang.org/cargo/reference/features.html

#![cfg_attr(feature = "nightly", feature(panic_info_message))]
#![warn(missing_docs)]

mod args;
mod async_tasks;
/// This module is *semver exempt*. This is not intended to be part of the public API of
/// wl-library-link.
///
/// Utility for catching panics, capturing a backtrace, and extracting the panic
/// message.
#[doc(hidden)]
pub mod catch_panic;
mod data_store;
mod library_data;
/// This module is *semver exempt*. This is not intended to be part of the public API of
/// wl-library-link.
///
/// Utilities used by code generated by the [`#[wolfram_library_function]`][wlf] macro.
///
/// [wlf]: attr.wolfram_library_function.html
#[doc(hidden)]
pub mod macro_utils;
mod numeric_array;
pub mod rtl;


use wl_expr::{Expr, ExprKind};
use wl_library_link_sys::{mint, WSLINK};
use wl_symbol_table as sym;
use wstp::Link;


pub use wl_library_link_sys as sys;
pub use wstp;

pub use self::{
    args::{from_args, FromArg, FromArgs},
    async_tasks::{spawn_async_task_with_thread, AsyncTask, AsyncTaskObject},
    data_store::DataStore,
    library_data::{get_library_data, initialize, WolframLibraryData},
    numeric_array::{
        NumericArray, NumericArrayDataType, NumericArrayKind, NumericArrayType,
        UninitNumericArray,
    },
};

/// Attribute to generate a [LibraryLink][library-link]-compatible wrapper around a Rust
/// function.
///
/// The wrapper function generated by this macro must be loaded using
/// [`LibraryFunctionLoad`][library-function-load], with [`LinkObject`][link-object] as
/// the argument and return value types.
///
/// A function written like:
///
/// ```
/// use wl_expr::Expr;
/// use wl_library_link::{WolframEngine, wolfram_library_function};
///
/// #[wolfram_library_function]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     for arg in args {
///         engine.evaluate(&Expr! { Print["Hello ", 'arg] });
///     }
///
///     Expr::null()
/// }
/// ```
///
/// can be loaded in the Wolfram Language by evaluating:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib",
///     "say_hello_wrapper",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
/// ## Options
///
/// #### Generated wrapper name
///
/// By default, the generated wrapper function will be the name of the function the
/// attribute it applied to with the fragment `_wrapper` appended. For example, the
/// function `say_hello` has a wrapper named `say_hello_wrapper`.
///
/// This can be controlled via the `name` option of `wolfram_library_function`, which sets
/// the name of generated Wolfram library function:
///
/// ```
/// # use wl_expr::Expr;
/// # use wl_library_link::{WolframEngine, wolfram_library_function};
/// #
/// #[wolfram_library_function(name = "WL_greet")]
/// pub fn say_hello(engine: &WolframEngine, args: Vec<Expr>) -> Expr {
///     // ...
/// #   Expr::null()
/// }
/// ```
///
/// The `LibraryFunctionLoad` invocation should change to:
///
/// ```wolfram
/// LibraryFunctionLoad[
///     "/path/to/target/debug/libmy_crate.dylib"
///     "WL_greet",
///     LinkObject,
///     LinkObject
/// ]
/// ```
///
///
/// [library-link]: https://reference.wolfram.com/language/guide/LibraryLink.html
/// [library-function-load]: https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
/// [link-object]: https://reference.wolfram.com/language/ref/LinkObject.html
#[doc(inline)]
pub use wolfram_library_function_macro::wolfram_library_function;

const BACKTRACE_ENV_VAR: &str = "LIBRARY_LINK_RUST_BACKTRACE";

//======================================
// WolframEngine
//======================================

/// Callbacks to the Wolfram Engine.
#[allow(non_snake_case)]
pub struct WolframEngine {
    wl_lib: sys::WolframLibraryData,

    // TODO: Is this function thread safe? Can it be called from a thread other than the
    //       one the LibraryLink wrapper was originally invoked from?
    AbortQ: unsafe extern "C" fn() -> mint,
    getWSLINK: unsafe extern "C" fn(sys::WolframLibraryData) -> WSLINK,
    processWSLINK: unsafe extern "C" fn(WSLINK) -> i32,
}

impl WolframEngine {
    /// Initialize a `WolframEngine` from the callbacks in a [`WolframLibraryData`]
    /// object.
    unsafe fn from_library_data(libdata: sys::WolframLibraryData) -> Self {
        // TODO(!): Use the library version to verify this is still correct?
        // TODO(!): Audit this
        // NOTE: That these fields are even an Option is likely just bindgen being
        //       conservative with function pointers possibly being null.
        // TODO: Investigate making bindgen treat these as non-null fields?
        let lib = *libdata;
        WolframEngine {
            wl_lib: libdata,

            AbortQ: lib.AbortQ.expect("AbortQ callback is NULL"),
            getWSLINK: lib.getWSLINK.expect("getWSLINK callback is NULL"),
            processWSLINK: lib.processWSLINK.expect("processWSLINK callback is NULL"),
        }
    }

    /// Returns `true` if the user has requested that the current evaluation be aborted.
    ///
    /// Programs should finish what they are doing and return control of this thread to
    /// to the kernel as quickly as possible. They should not exit the process or
    /// otherwise terminate execution, simply return up the call stack.
    ///
    /// Within Rust code reached through a `#[wolfram_library_function]` wrapper,
    /// `panic!()` can be used to quickly unwind the call stack to the appropriate place.
    /// Note that this will not work if the current library is built with
    /// `panic = "abort"`. See the [`panic`][panic-option] profile configuration option
    /// for more information.
    ///
    /// [panic-option]: https://doc.rust-lang.org/cargo/reference/profiles.html#panic
    pub fn aborted(&self) -> bool {
        let val: mint = unsafe { (self.AbortQ)() };
        val == 1
    }

    /// Evaluate `expr` by calling back into the Wolfram Kernel.
    ///
    /// TODO: Specify and document what happens if the evaluation of `expr` triggers a
    ///       kernel abort (such as a `Throw[]` in the code).
    pub fn evaluate(&self, expr: &Expr) -> Expr {
        match self.try_evaluate(expr) {
            Ok(returned) => returned,
            Err(msg) => panic!(
                "WolframEngine::evaluate: evaluation of expression failed: \
                {}: \n\texpression: {}",
                msg, expr
            ),
        }
    }

    /// Attempt to evaluate `expr`, returning an error if a WSTP transport error occurred
    /// or evaluation failed.
    pub fn try_evaluate(&self, expr: &Expr) -> Result<Expr, String> {
        let mut link = self.get_wstp_link();

        // Send an EvaluatePacket['expr].
        let _: () = link
            .put_expr(&Expr! { EvaluatePacket['expr] })
            .map_err(|e| e.to_string())?;

        let _: () = self.process_wstp_link(&link)?;

        let return_packet: Expr = link.get_expr().map_err(|e| e.to_string())?;

        let returned_expr = match return_packet.kind() {
            ExprKind::Normal(normal) => {
                debug_assert!(normal.has_head(&*sym::ReturnPacket));
                debug_assert!(normal.contents.len() == 1);
                normal.contents[0].clone()
            },
            _ => return Err(format!(
                "WolframEngine::try_evaluate: returned expression was not ReturnPacket: {}",
                return_packet
            )),
        };

        Ok(returned_expr)
    }

    fn get_wstp_link(&self) -> Link {
        unsafe {
            let unsafe_link = (self.getWSLINK)(self.wl_lib);
            // Go from *mut MLINK -> *mut WSLINK
            Link::unchecked_new(unsafe_link as *mut _)
        }
    }

    fn process_wstp_link(&self, link: &Link) -> Result<(), String> {
        let raw_link = unsafe { link.raw_link() };

        // Process the packet on the link.
        let code: i32 = unsafe { (self.processWSLINK)(raw_link as *mut _) };

        if code == 0 {
            let error_message = link
                .error_message()
                .unwrap_or_else(|| "unknown error occurred on WSTP Link".into());

            return Err(error_message);
        }

        Ok(())
    }
}

// TODO: Allow any type which implements FromExpr in wrapper parameter lists?
